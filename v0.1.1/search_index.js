var documenterSearchIndex = {"docs":
[{"location":"project.html#History","page":"About the package","title":"History","text":"","category":"section"},{"location":"project.html","page":"About the package","title":"About the package","text":"In 2006 Bernd Blasius and I did some calculations that predicted something surprising: Under certain circumstances, the way society reacts to an epidemic disease can lead to oscillations where the prevalence of an epidemic increases and decreases in a regular pattern. That was a nice new insight but to verify the maths we needed to run agent-based simulations.","category":"page"},{"location":"project.html","page":"About the package","title":"About the package","text":"In small simulations the predicted oscillations did not happen. The reason was that even in a simulation with some thousand agents random events randomness at the agent level can still have a significant impact. This created a lot of noise that destroyed the oscillations.","category":"page"},{"location":"project.html","page":"About the package","title":"About the package","text":"We needed bigger simulations. Agent based simulations on a network suffer from bad data locality and hence don't parallelize well. So they remain challenging.","category":"page"},{"location":"project.html","page":"About the package","title":"About the package","text":"In principle agent-based simulation can be done extremely quickly using a technique called event-driven (Gillespie) simulation. In an event driven simulation there is certain functions that are called many times: finding out how many agents are in a given state (i.e. infected), picking a random agent who has a certain state and changing the state an agent is in.","category":"page"},{"location":"project.html","page":"About the package","title":"About the package","text":"To speed up my simulations I came up with the Repo data structure. Repo implements the three tasks (counting, choosing, changing) such that their execution times are independent of the number of agents.","category":"page"},{"location":"project.html","page":"About the package","title":"About the package","text":"In agent-based modelling, and perhaps other computational Repo enables creating some very fast codes. In our case that allowed to run very fast epidemic simulations with tens of millions of agents. The paper from our initial application, described above is","category":"page"},{"location":"project.html","page":"About the package","title":"About the package","text":"T. Gross, C. Dommar D'Lima and B. Blasius: Epidemic dynamics on an adaptive network. Physical Review Letters 96, 208701, (2006).","category":"page"},{"location":"project.html","page":"About the package","title":"About the package","text":"The Repos.jl package is the first implementation of Repo in Julia.  ","category":"page"},{"location":"project.html#Contributing","page":"About the package","title":"Contributing","text":"","category":"section"},{"location":"project.html","page":"About the package","title":"About the package","text":"I welcome contributions and feature requests.","category":"page"},{"location":"project.html#Acknowledgements","page":"About the package","title":"Acknowledgements","text":"","category":"section"},{"location":"project.html","page":"About the package","title":"About the package","text":"The original development of Repo was supported by the Volkswagen foundation. The current implementation in Julia was developed at HIFMB, a collaboration between the Alfred-Wegener-Institute, Helmholtz-Center for Polar and Marine Research, and the Carl-von-Ossietzky University Oldenburg, initially funded by the Ministry for Science and Culture of Lower Saxony (MWK) and the Volkswagen Foundation through the “Nieders&auml;chsisches Vorab” grant program (grant number ZN3285).","category":"page"},{"location":"functions.html#Function-reference","page":"List of functions","title":"Function reference","text":"","category":"section"},{"location":"functions.html","page":"List of functions","title":"List of functions","text":"This page contains the complete documentation of Repo functions. Between I have inserted some comments and explanations of the underlying philosophy, as well as some usage notes.","category":"page"},{"location":"functions.html#Construction","page":"List of functions","title":"Construction","text":"","category":"section"},{"location":"functions.html","page":"List of functions","title":"List of functions","text":"Repo objects can be constructed either from an existing 1-dimensional array or by specifying the element type and number. In both cases the number of classes must be specified.","category":"page"},{"location":"functions.html","page":"List of functions","title":"List of functions","text":"    Repo{T}(N::Int,C::Int) where T\r\n    Repo(a::Array{T,1},C::Int) where T","category":"page"},{"location":"functions.html#Repos.Repo-Union{Tuple{Int64,Int64}, Tuple{T}} where T","page":"List of functions","title":"Repos.Repo","text":"Repo{T}(N::Int,C::Int) where T\n\nCreate a repository that organizes N elements of type T into C classes.\n\nExample\n\njulia> using Repos\n\njulia> r=Repo{String}(50000,4)\nRepository of 50000 objects in 4 classes\n\n\n\n\n\n","category":"method"},{"location":"functions.html#Repos.Repo-Union{Tuple{T}, Tuple{Array{T,1},Int64}} where T","page":"List of functions","title":"Repos.Repo","text":"Repo(a::Array,C::Int)\n\nCreate a repository that organizes an existing array into C classes.\n\nThe repository will not copy the array, so the memory is only allocated once and any changes you make in the array will be reflected in the repository.\n\nExample\n\njulia> using Repos\n\njulia> a=[\"red\",\"green\",\"blue\"];\n\njulia> r=Repo(a,2)\nRepository of 3 objects in 2 classes\n\njulia> a[1]=\"cyan\";\n\njulia> print_repo(r)\nRepository of 2 classes\n  Class 1\n    1 - 1: cyan\n    2 - 2: green\n    3 - 3: blue\n  Class 2\n\n\n\n\n\n","category":"method"},{"location":"functions.html","page":"List of functions","title":"List of functions","text":"Repo is optimized to deal with very large number of elements. The runtime of most functions should be independent of the number of elements and linear in the number of classes.","category":"page"},{"location":"functions.html","page":"List of functions","title":"List of functions","text":"Once the repository has been created the number of elements and classes cannot be changed. If you are unsure of how many elements you need, make the Repo large enough and assign unused elements to one class, so one class basically becomes the storage space for unused elements.","category":"page"},{"location":"functions.html#Class-functions","page":"List of functions","title":"Class functions","text":"","category":"section"},{"location":"functions.html","page":"List of functions","title":"List of functions","text":"The central concept of Repo is that elements stored in the Repo can be categorized into different classes, where each class is identified by a numerical value. You can set and retrieve the class of an element by the following two functions:","category":"page"},{"location":"functions.html","page":"List of functions","title":"List of functions","text":"    getclass(repo::Repo{T},id::Int) where T\r\n    setclass!(repo::Repo{T},id::Int,cls::Int) where T","category":"page"},{"location":"functions.html#Repos.getclass-Union{Tuple{T}, Tuple{Repo{T},Int64}} where T","page":"List of functions","title":"Repos.getclass","text":"getclass(repo::Repo{T},id::Int)\n\nReturn the class number of element id in  repo.\n\nExample\n\njulia> using Repos\n\njulia> r=Repo([\"red\",\"green\",\"blue\"],2)\nRepository of 3 objects in 2 classes\n\njulia> getclass(r,1)\n1\n\n\n\n\n\n","category":"method"},{"location":"functions.html#Repos.setclass!-Union{Tuple{T}, Tuple{Repo{T},Int64,Int64}} where T","page":"List of functions","title":"Repos.setclass!","text":"setclass!(repo::Repo{T},id::Int,cls::Int) where T\n\nChange the class of item number id in repo to cls.\n\nExample\n\njulia> using Repos\n\njulia> r=Repo([\"red\",\"green\",\"blue\"],2)\nRepository of 3 objects in 2 classes\n\njulia> setclass!(r,1,2)\n\njulia> print_repo(r)\nRepository of 2 classes\n  Class 1\n    1 - 3: blue\n    2 - 2: green\n  Class 2\n    1 - 1: red\n\n\n\n\n\n","category":"method"},{"location":"functions.html","page":"List of functions","title":"List of functions","text":"An interesting function is the class() function this function returns an interface object of type RepoClass. This interface acts as a portal to access the elements in the respective class. It will always remain up to date (No data is actually copied into the interface object).","category":"page"},{"location":"functions.html","page":"List of functions","title":"List of functions","text":"class(repo::Repo{T},c::Int) where T","category":"page"},{"location":"functions.html#Repos.class-Union{Tuple{T}, Tuple{Repo{T},Int64}} where T","page":"List of functions","title":"Repos.class","text":" class(repo::Repo{T},c::Int)\n\nReturn an interface to class c in repository repo.\n\nThe returned RepoClass structure is an interface to the object of the respective class in the repository. The RepoClass will stay up to date when the repository is updated.\n\nExample\n\njulia> using Repos\n\njulia> a=[\"Golden Delicious\",\"Granny Smith\",\"Red Delicious\",\"Valencia\"]\n4-element Array{String,1}:\n \"Golden Delicious\"\n \"Granny Smith\"\n \"Red Delicious\"\n \"Valencia\"\n\njulia> r=Repo(a,2)\nRepository of 4 objects in 2 classes\n\njulia> apples=class(r,1)\nClass of 4 objects\n\njulia> setclass!(r,4,2)\n\njulia> a[3]=\"Braeburn\"\n\"Braeburn\"\n\njulia> print_repo(apples)\nClass of 3 objects\n    1 - 1: Golden Delicious\n    2 - 2: Granny Smith\n    3 - 3: Braeburn\n\n\n\n\n\n","category":"method"},{"location":"functions.html#ID-and-Length","page":"List of functions","title":"ID and Length","text":"","category":"section"},{"location":"functions.html","page":"List of functions","title":"List of functions","text":"There are two ways to identify an element in the Repo. First, you can identify an element by it's ID number. This number will always refer to the same element. If you created the Repo from an array, the ID will be identical to the elements number in the array.","category":"page"},{"location":"functions.html","page":"List of functions","title":"List of functions","text":"Second, you can identify an element by its class and position in the class. This is useful for example for iterating through a class or picking a random element from the class. However, in contrast to ID the position of an element in a class can change when setclass!() is called. If you say, pick using class and position and want to remember which element you picked for later use, you should store it's ID which can be determined by the following functions:","category":"page"},{"location":"functions.html","page":"List of functions","title":"List of functions","text":"    repo_id(repo::Repo{T},c::Int,pos::Int) where T","category":"page"},{"location":"functions.html#Repos.repo_id-Union{Tuple{T}, Tuple{Repo{T},Int64,Int64}} where T","page":"List of functions","title":"Repos.repo_id","text":"repo_id(repo::Repo{T},c::Int,pos::Int)\nrepo_id(repo::Repo{T},pos::Int)\nrepo_id(cls::RepoClass{T},pos::Int)\n\nGet the permanent id of an item in the repository identified by current position or current class and and current position.\n\nIn contrast to the position, which can change when setclass is called, the id of an item never changes.\n\nExample\n\njulia> using Repos\n\njulia> r=Repo([1:10...],3)\nRepository of 10 objects in 3 classes\n\njulia> repo_id(r,1)\n1\n\njulia> setclass!(r,1,3)\n\njulia> repo_id(r,1)\n10\n\njulia> repo_id(r,3,1)\n1\n\n\n\n\n\n","category":"method"},{"location":"functions.html","page":"List of functions","title":"List of functions","text":"To determine the size of the repository or the elements in a certain class use the length() function.","category":"page"},{"location":"functions.html#Example","page":"List of functions","title":"Example","text":"","category":"section"},{"location":"functions.html","page":"List of functions","title":"List of functions","text":"julia> using Repos\r\n\r\njulia> villain=Repo([\"Dracula\",\"Frankenstein\",\"Hyde\",\"Catwoman\"],2)\r\nRepository of 4 objects in 2 classes\r\n\r\njulia> setclass!(villain,4,2)\r\n\r\njulia> victorian=class(villain,1)\r\nClass of 3 objects\r\n\r\njulia> modern=class(villain,2)\r\nClass of 1 objects\r\n\r\njulia> length(villain)\r\n4\r\n\r\njulia> length(victorian)\r\n3\r\n\r\njulia> length(modern)\r\n1","category":"page"},{"location":"functions.html#Element-access","page":"List of functions","title":"Element access","text":"","category":"section"},{"location":"functions.html","page":"List of functions","title":"List of functions","text":"You can access element with \"[]\" like you would in a vector. The elements can be identified either by their id or by class and position. (see the notes on position, above)","category":"page"},{"location":"functions.html#Example-2","page":"List of functions","title":"Example","text":"","category":"section"},{"location":"functions.html","page":"List of functions","title":"List of functions","text":"julia> using Repos\r\n\r\njulia> numbers=Repo([1:1000...],2)\r\nRepository of 1000 objects in 2 classes\r\n\r\njulia> setclass!(numbers,123,2)\r\n\r\njulia> numbers[1]\r\n1\r\n\r\njulia> numbers[123]\r\n123\r\n\r\njulia> numbers[2,1]\r\n123\r\n\r\njulia> numbers[2,1]=-5\r\n-5\r\n\r\njulia> numbers[123]\r\n-5\r\n\r\njulia> numbers[1]=-7\r\n-7\r\n\r\njulia> numbers[1,1]\r\n-7","category":"page"},{"location":"functions.html","page":"List of functions","title":"List of functions","text":"If you created a Repo from an array you can also change the repo elements by changing the original array (Repo does not hardcopy the array at creation.)","category":"page"},{"location":"functions.html#Example-3","page":"List of functions","title":"Example","text":"","category":"section"},{"location":"functions.html","page":"List of functions","title":"List of functions","text":"julia> using Repos\r\n\r\njulia> cities=[\"Kuala Lumpur\",\"Moscow\",\"San Francisco\",\"London\",\"Rio de Janeiro\"]\r\n5-element Array{String,1}:\r\n \"Kuala Lumpur\"\r\n \"Moscow\"\r\n \"San Francisco\"\r\n \"London\"\r\n \"Rio de Janeiro\"\r\n\r\njulia> repo=Repo(cities,2)\r\nRepository of 5 objects in 2 classes\r\n\r\njulia> capitals=class(repo,1)\r\nClass of 5 objects\r\n\r\njulia> setclass!(repo,3,2)\r\n\r\njulia> setclass!(repo,5,2)\r\n\r\njulia> print_repo(repo)\r\nRepository of 2 classes\r\n  Class 1\r\n    1 - 1: Kuala Lumpur\r\n    2 - 2: Moscow\r\n    3 - 4: London\r\n  Class 2\r\n    1 - 5: Rio de Janeiro\r\n    2 - 3: San Francisco\r\n\r\njulia> cities[5] = \"Bristol\"\r\n\"Bristol\"\r\n\r\njulia> repo[5]\r\n\"Bristol\"\r\n\r\njulia> repo[2,1]\r\n\"Bristol\"","category":"page"},{"location":"functions.html#Iteration","page":"List of functions","title":"Iteration","text":"","category":"section"},{"location":"functions.html","page":"List of functions","title":"List of functions","text":"You can iterate over either the Repo or a RepoClass using standard \"for\" iteration.","category":"page"},{"location":"functions.html#Example-4","page":"List of functions","title":"Example","text":"","category":"section"},{"location":"functions.html","page":"List of functions","title":"List of functions","text":"julia> using Repos\r\n\r\njulia> rock=Repo([\"Granite\",\"Diorite\",\"Gabbro\",\"Andesite\",\"Basalt\"],2)\r\nRepository of 5 objects in 2 classes\r\n\r\njulia> setclass!(rock,3,2)\r\n\r\njulia> setclass!(rock,5,2)\r\n\r\njulia> mafic=class(rock,2)\r\nClass of 2 objects\r\n\r\njulia> for x in rock println(x) end\r\nGranite\r\nDiorite\r\nGabbro\r\nAndesite\r\nBasalt\r\n\r\njulia> for x in mafic println(x) end\r\nBasalt\r\nGabbro","category":"page"},{"location":"functions.html","page":"List of functions","title":"List of functions","text":"When iterating over the whole Repo the elements are presented in order of element id. When iterating over a class the elements are presented in the order of position withinthe class. So the order can change whenever setclass!() is called.","category":"page"},{"location":"functions.html","page":"List of functions","title":"List of functions","text":"In the case where functions in the for loop change the class of elements the iteration will still run over all objects that were in the respective class at the start of the loop. So every object that is in the respective class when the iteration starts will be iterated over exactly once.  ","category":"page"},{"location":"functions.html","page":"List of functions","title":"List of functions","text":"If different behavior is desired iterate over the elements using the length() and [].","category":"page"},{"location":"functions.html#Printing","page":"List of functions","title":"Printing","text":"","category":"section"},{"location":"functions.html","page":"List of functions","title":"List of functions","text":"For debugging purposes an overview of a Repo or RepoClass object can be printed. ","category":"page"},{"location":"functions.html","page":"List of functions","title":"List of functions","text":"    print_repo(repo::Repo{T},nax::Int=10) where T","category":"page"},{"location":"functions.html#Repos.print_repo-Union{Tuple{T}, Tuple{Repo{T}}, Tuple{Repo{T},Int64}} where T","page":"List of functions","title":"Repos.print_repo","text":"print_repo(repo::Repo{T},nax::Int=10)\nprint_repo(cls::RepoClass{T},max::Int=10)\nprint_repo(io::IO,repo::Repo{T},nax::Int=10)\nprint_repo(io::IO,cls::RepoClass{T},max::Int=10)\n\nPrint a summary of the contents of the repository repo or the repository class cls to REPL or another IO device.\n\nThe output lists the classes and shows the first and last entries in every class. For each entry the current position in the class, the id of the entry, and the content of the entry are printed.\n\nAn optional parameter max can be specified to control the number of entries that are shown in every repository class. If this parameter is set to less than 2 all entries are shown. (Warning: For large repositories this can take a while)\n\nExample\n\njulia> using Repos\n\njulia> r=Repo([\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\"],2)\nRepository of 7 objects in 2 classes\n\njulia> setclass!(r,1,2)\n\njulia> setclass!(r,5,2)\n\njulia> vowels=class(r,2)\nClass of 2 objects\n\njulia> print_repo(vowels)\nClass of 2 objects\n    1 - 5: E\n    2 - 1: A\n\njulia> r=Repo([1:10000...],2)\nRepository of 10000 objects in 2 classes\n\njulia> setclass!(r,1337,2)\n\njulia> print_repo(r,4)\nRepository of 2 classes\n  Class 1\n    1 - 1: 1\n    2 - 2: 2\n    ...\n    9998 - 9998: 9998\n    9999 - 9999: 9999\n  Class 2\n    1 - 1337: 1337\n\n\n\n\n\n","category":"method"},{"location":"interfaces.html#Repo.jl-Iteration-and-Interfaces","page":"Repo.jl - Iteration and Interfaces","title":"Repo.jl - Iteration and Interfaces","text":"","category":"section"},{"location":"installation.html#Installation","page":"-","title":"Installation","text":"","category":"section"},{"location":"installation.html","page":"-","title":"-","text":"Install with the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and","category":"page"},{"location":"installation.html","page":"-","title":"-","text":"pkg> add Repos","category":"page"},{"location":"installation.html","page":"-","title":"-","text":"Alternatively from Julia","category":"page"},{"location":"installation.html","page":"-","title":"-","text":"julia> import Pkg\r\n\r\njulia> Pkg.add(\"Repos\")","category":"page"},{"location":"index.html#Repos.jl","page":"Getting started","title":"Repos.jl","text":"","category":"section"},{"location":"index.html","page":"Getting started","title":"Getting started","text":"Repos provides a highly efficient data structure (Repo) that can be used for organizing data into a set of \"classes\".","category":"page"},{"location":"index.html","page":"Getting started","title":"Getting started","text":"Repo behaves like an array, where you can additionally assign each element of the array to a \"class\". You can dynamically change the an element's class, find out how many elements are in a certain class, iterate through the elements in a given class or pick a single element from a class (e.g. at random).","category":"page"},{"location":"index.html","page":"Getting started","title":"Getting started","text":"Importantly, the time required for these operations is independent of the number of elements stored in Repo and only linearly increases with the number of classes. Thereby Repo enables extremely fast (linear time) agent-based simulations.   ","category":"page"},{"location":"index.html#Showcase","page":"Getting started","title":"Showcase","text":"","category":"section"},{"location":"index.html","page":"Getting started","title":"Getting started","text":"julia> using Repos\r\n\r\njulia> ar=[\"Crimson\",\"Azure\",\"Scarlett\",\"Indigo\",(169,19,0)]\r\n5-element Array{Any,1}:\r\n \"Crimson\"\r\n \"Azure\"\r\n \"Scarlett\"\r\n \"Indigo\"\r\n (169, 19, 0)\r\n\r\njulia> colors=Repo(ar,2)\r\nRepository of 5 objects in 2 classes\r\n\r\njulia> reds=class(colors,1)\r\nClass of 5 objects\r\n\r\njulia> setclass!(colors,2,2)   #Set the class of object 2 to 2\r\n\r\njulia> setclass!(colors,4,2)\r\n\r\njulia> print_repo(colors)\r\nRepository of 2 classes\r\n  Class 1\r\n    1 - 1: Crimson\r\n    2 - 5: (169, 19, 0)\r\n    3 - 3: Scarlett\r\n  Class 2\r\n    1 - 4: Indigo\r\n    2 - 2: Azure\r\n\r\njulia> reds\r\nClass of 3 objects\r\n\r\njulia> blues=class(colors,2)\r\nClass of 2 objects\r\n\r\njulia> blues[1]\r\n\"Indigo\"\r\n\r\njulia> blues[2]\r\n\"Azure\"","category":"page"},{"location":"index.html#Project-Status","page":"Getting started","title":"Project Status","text":"","category":"section"},{"location":"index.html","page":"Getting started","title":"Getting started","text":"This package was tested on Julia 1.4.2 on Windows.","category":"page"},{"location":"idvspos.html#Repo.jl-ID-vs-Position","page":"Repo.jl - ID vs Position","title":"Repo.jl - ID vs Position","text":"","category":"section"}]
}
