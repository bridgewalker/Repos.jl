var documenterSearchIndex = {"docs":
[{"location":"project.html#History","page":"About the Package","title":"History","text":"","category":"section"},{"location":"project.html","page":"About the Package","title":"About the Package","text":"In 2006 Bernd Blasius and I did some calculations that predicted something surprising: Under certain circumstances, the way society reacts to an epidemic disease can lead to oscillations where the prevalence of an epidemic increases and decreases in a regular pattern. That was a nice new insight but to verify the maths we needed to run agent-based simulations.","category":"page"},{"location":"project.html","page":"About the Package","title":"About the Package","text":"In small simulations the predicted oscillations did not happen. The reason was that even in a simulation with some thousand agents random events randomness at the agent level can still have a significant impact. This created a lot of noise that destroyed the oscillations.","category":"page"},{"location":"project.html","page":"About the Package","title":"About the Package","text":"We needed bigger simulations. Agent based simulations on a network suffer from bad data locality and hence don't parallelize well. So they remain challenging.","category":"page"},{"location":"project.html","page":"About the Package","title":"About the Package","text":"In principle agent-based simulation can be done extremely quickly using a technique called event-driven (Gillespie) simulation. In an event driven simulation there is certain functions that are called many times: finding out how many agents are in a given state (i.e. infected), picking a random agent who has a certain state and changing the state an agent is in.","category":"page"},{"location":"project.html","page":"About the Package","title":"About the Package","text":"To speed up my simulations I came up with the Repo data structure. Repo implements the three tasks (counting, choosing, changing) such that their execution times are independent of the number of agents.","category":"page"},{"location":"project.html","page":"About the Package","title":"About the Package","text":"In agent-based modelling, and perhaps other computational Repo enables creating some very fast codes. In our case that allowed to run very fast epidemic simulations with tens of millions of agents. The paper from our initial application, described above is","category":"page"},{"location":"project.html","page":"About the Package","title":"About the Package","text":"T. Gross, C. Dommar D'Lima and B. Blasius: Epidemic dynamics on an adaptive network. Physical Review Letters 96, 208701, (2006).","category":"page"},{"location":"project.html","page":"About the Package","title":"About the Package","text":"The Repos.jl package is the first implementation of Repo in Julia.  ","category":"page"},{"location":"project.html#Contributing","page":"About the Package","title":"Contributing","text":"","category":"section"},{"location":"project.html","page":"About the Package","title":"About the Package","text":"I welcome contributions and feature requests.","category":"page"},{"location":"project.html#Acknowledgements","page":"About the Package","title":"Acknowledgements","text":"","category":"section"},{"location":"project.html","page":"About the Package","title":"About the Package","text":"The original development of Repo was supported by the Volkswagen foundation. The current implementation in Julia was developed at HIFMB, a collaboration between the Alfred-Wegener-Institute, Helmholtz-Center for Polar and Marine Research, and the Carl-von-Ossietzky University Oldenburg, initially funded by the Ministry for Science and Culture of Lower Saxony (MWK) and the Volkswagen Foundation through the “Nieders&auml;chsisches Vorab” grant program (grant number ZN3285).","category":"page"},{"location":"functions.html#List-of-Functions","page":"List of Functions","title":"List of Functions","text":"","category":"section"},{"location":"functions.html","page":"List of Functions","title":"List of Functions","text":"    getclass(repo::Repo{T},id::Int) where T","category":"page"},{"location":"functions.html#Repos.getclass-Union{Tuple{T}, Tuple{Repo{T},Int64}} where T","page":"List of Functions","title":"Repos.getclass","text":"getclass(repo::Repo{T},id::Int)\n\nReturn the class number of element id in  repo.\n\nExample\n\njulia> using Repos\n\njulia> r=Repo([\"red\",\"green\",\"blue\"],2)\nRepository of 3 objects in 2 classes\n\njulia> getclass(r,1)\n1\n\n\n\n\n\n","category":"method"},{"location":"interfaces.html#Repo.jl-Iteration-and-Interfaces","page":"Repo.jl - Iteration and Interfaces","title":"Repo.jl - Iteration and Interfaces","text":"","category":"section"},{"location":"installation.html#Installation","page":"-","title":"Installation","text":"","category":"section"},{"location":"installation.html","page":"-","title":"-","text":"Install with the Julia package manager. From the Julia REPL, type ] to enter the Pkg REPL mode and","category":"page"},{"location":"installation.html","page":"-","title":"-","text":"pkg> add Repos","category":"page"},{"location":"installation.html","page":"-","title":"-","text":"Alternatively from Julia","category":"page"},{"location":"installation.html","page":"-","title":"-","text":"julia> import Pkg\r\n\r\njulia> Pkg.add(\"Repos\")","category":"page"},{"location":"index.html#Repos.jl","page":"Getting Started","title":"Repos.jl","text":"","category":"section"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"Repos provides a highly efficient data structure (Repo) that can be used for organizing data into a set of \"classes\".","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"Repo behaves like an array, where you can additionally assign each element of the array to a \"class\". You can dynamically change the an element's class, find out how many elements are in a certain class, iterate through the elements in a given class or pick a single element from a class (e.g. at random).","category":"page"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"Importantly, the time required for these operations is independent of the number of elements stored in Repo and only linearly increases with the number of classes. Thereby Repo enables extremely fast (linear time) agent-based simulations.   ","category":"page"},{"location":"index.html#Showcase","page":"Getting Started","title":"Showcase","text":"","category":"section"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"julia> using Repos\r\n\r\njulia> ar=[\"Crimson\",\"Azure\",\"Scarlett\",\"Indigo\",(169,19,0)]\r\n5-element Array{Any,1}:\r\n \"Crimson\"\r\n \"Azure\"\r\n \"Scarlett\"\r\n \"Indigo\"\r\n (169, 19, 0)\r\n\r\njulia> colors=Repo(ar,2)\r\nRepository of 5 objects in 2 classes\r\n\r\njulia> reds=class(colors,1)\r\nClass of 5 objects\r\n\r\njulia> setclass!(colors,2,2)   #Set the class of object 2 to 2\r\n\r\njulia> setclass!(colors,4,2)\r\n\r\njulia> print_repo(colors)\r\nRepository of 2 classes\r\n  Class 1\r\n    1 - 1: Crimson\r\n    2 - 5: (169, 19, 0)\r\n    3 - 3: Scarlett\r\n  Class 2\r\n    1 - 4: Indigo\r\n    2 - 2: Azure\r\n\r\njulia> reds\r\nClass of 3 objects\r\n\r\njulia> blues=class(colors,2)\r\nClass of 2 objects\r\n\r\njulia> blues[1]\r\n\"Indigo\"\r\n\r\njulia> blues[2]\r\n\"Azure\"","category":"page"},{"location":"index.html#Project-Status","page":"Getting Started","title":"Project Status","text":"","category":"section"},{"location":"index.html","page":"Getting Started","title":"Getting Started","text":"This package was tested on Julia 1.4.2 on Windows.","category":"page"},{"location":"idvspos.html#Repo.jl-ID-vs-Position","page":"Repo.jl - ID vs Position","title":"Repo.jl - ID vs Position","text":"","category":"section"}]
}
